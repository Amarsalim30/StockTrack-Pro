import 'dart:io';
import 'package:path/path.dart' as p;

final modelsDir = Directory('lib/data/models');
final entitiesDir = Directory('lib/domain/entities');
final mappersDir = Directory('lib/data/mappers');

const header = '// GENERATED BY AMAR SCRIPT – EDIT MODEL';
const overwriteAll = true; // set to false to skip manual files

void main() async {
  if (!modelsDir.existsSync()) {
    print('❌ Models directory not found: ${modelsDir.path}');
    return;
  }

  final modelFiles = modelsDir
      .listSync(recursive: true)
      .whereType<File>()
      .where(
        (f) => f.path.endsWith('_model.dart') && !f.path.endsWith('.g.dart'),
      );

  for (var file in modelFiles) {
    final src = await file.readAsString();
    final info = _parseModel(src);
    if (info == null) {
      print('⚠️ Could not parse: ${p.relative(file.path)}');
      continue;
    }

    final modelClass = info['class']!;
    final entityClass = modelClass.replaceAll('Model', '');
    final fields = info['fields'] as List<Map<String, String>>;

    // Entity Path
    final entPath = p.join(
      entitiesDir.path,
      p
          .relative(file.path, from: modelsDir.path)
          .replaceAll('_model.dart', '.dart'),
    );

    // Mapper Path
    final mapPath = p.join(
      mappersDir.path,
      p
          .relative(file.path, from: modelsDir.path)
          .replaceAll('_model.dart', '_mapper.dart'),
    );

    // Create entity
    await _writeIfAllowed(entPath, () => _buildEntity(entityClass, fields));
    // Create mapper
    await _writeIfAllowed(
      mapPath,
      () => _buildMapper(modelClass, entityClass, fields),
    );
  }

  print('\n✅ Done generating Entities & Mappers.');
}

Map<String, dynamic>? _parseModel(String src) {
  final classMatch = RegExp(
    r'class (\w+Model)\s*(extends\s+\w+)?\s*{',
  ).firstMatch(src);
  if (classMatch == null) return null;

  final className = classMatch.group(1)!;
  final bodyStart = classMatch.end;
  final bodyEnd = src.indexOf('}', bodyStart);
  if (bodyEnd == -1) return null;

  final body = src.substring(bodyStart, bodyEnd);
  final fieldMatches = RegExp(r'final\s+([\w<>?]+)\s+(\w+);')
      .allMatches(body)
      .map((m) => {'type': m.group(1)!, 'name': m.group(2)!})
      .toList();

  return {'class': className, 'fields': fieldMatches};
}

Future<void> _writeIfAllowed(String path, String Function() build) async {
  final file = File(path);
  final content = build();
  if (file.existsSync()) {
    final existing = await file.readAsString();
    if (!existing.contains(header) && !overwriteAll) {
      print('⚠️ Skipped manual file: ${p.relative(path)}');
      return;
    }
    if (existing == content) {
      print('ℹ️ No changes for: ${p.relative(path)}');
      return;
    }
  }
  file.createSync(recursive: true);
  await file.writeAsString(content);
  print('✅ Wrote: ${p.relative(path)}');
}

String _buildEntity(String name, List<Map<String, String>> fields) {
  final fieldDecl = fields
      .map((f) => '  final ${f['type']} ${f['name']};')
      .join('\n');

  final ctorParams = fields
      .map((f) {
        final req = f['type']!.endsWith('?') ? '' : 'required ';
        return '    $req this.${f['name']},';
      })
      .join('\n');

  final props = fields.map((f) => f['name']).join(', ');

  final copyWithParams = fields
      .map((f) => '${f['type']}? ${f['name']}')
      .join(', ');
  final copyWithBody = fields
      .map((f) => '${f['name']}: ${f['name']} ?? this.${f['name']},')
      .join('\n      ');

  return '''
$header
import 'package:equatable/equatable.dart';

class $name extends Equatable {
$fieldDecl

  const $name({
$ctorParams
  });

  $name copyWith({$copyWithParams}) {
    return $name(
      $copyWithBody
    );
  }

  @override
  List<Object?> get props => [$props];
}
''';
}

String _buildMapper(
  String modelClass,
  String entityClass,
  List<Map<String, String>> fields,
) {
  final modelFile = modelClass[0].toLowerCase() + modelClass.substring(1);
  final entityFile = entityClass[0].toLowerCase() + entityClass.substring(1);

  final im1 = "import 'package:clean_arch_app/data/models/$modelFile.dart';";
  final im2 =
      "import 'package:clean_arch_app/domain/entities/$entityFile.dart';";

  final toEntity = fields
      .map((f) {
        final n = f['name']!;
        final t = f['type']!;
        if (t.startsWith('List<')) {
          final inner = RegExp(r'List<(\w+)>').firstMatch(t)?.group(1);
          if (inner == null) return '      $n: model.$n,';
          final mapper = inner.endsWith('Model')
              ? '${inner.replaceAll('Model', '')}Mapper.toEntity'
              : '$inner Mapper.toEntity';
          return '      $n: model.$n${t.endsWith('?') ? '?' : ''}.map((e) => $mapper(e)).toList(),';
        } else if (t.endsWith('Model')) {
          final ent = t.replaceAll('Model', '');
          return '      $n: ${ent}Mapper.toEntity(model.$n!),';
        } else {
          return '      $n: model.$n,';
        }
      })
      .join('\n');

  final fromEntity = fields
      .map((f) {
        final n = f['name']!;
        final t = f['type']!;
        if (t.startsWith('List<')) {
          final inner = RegExp(r'List<(\w+)>').firstMatch(t)?.group(1);
          if (inner == null) return '      $n: entity.$n,';
          final mapper = inner.endsWith('Model')
              ? '${inner.replaceAll('Model', '')}Mapper.fromEntity'
              : '$inner Mapper.fromEntity';
          return '      $n: entity.$n${t.endsWith('?') ? '?' : ''}.map((e) => $mapper(e)).toList(),';
        } else if (t.endsWith('Model')) {
          final ent = t.replaceAll('Model', '');
          return '      $n: ${ent}Mapper.fromEntity(entity.$n!),';
        } else {
          return '      $n: entity.$n,';
        }
      })
      .join('\n');

  return '''
$header
$im1
$im2

class ${entityClass}Mapper {
  static $entityClass toEntity($modelClass model) {
    return $entityClass(
$toEntity
    );
  }

  static $modelClass fromEntity($entityClass entity) {
    return $modelClass(
$fromEntity
    );
  }
}
''';
}
